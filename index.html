<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>人脸识别数据降维可视化 (修正版)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f5f5; padding: 20px; color: #333; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { text-align: center; color: #2c3e50; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; margin-top: 40px; }
        .gallery { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0; }
        .face-card { text-align: center; font-size: 12px; }
        canvas { border: 1px solid #ccc; image-rendering: pixelated; width: 60px; height: 60px; } 
        .btn { display: block; width: 200px; margin: 20px auto; padding: 10px; background: #3498db; color: white; text-align: center; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        .btn:hover { background: #2980b9; }
        #loading { text-align: center; color: #7f8c8d; display: none; }
    </style>
</head>
<body>

<div class="container">
    <h1>人脸数据特征提取与降维 Demo</h1>
    <p style="text-align: center;">模拟 10x10 像素的笑脸与哭脸数据 (已随机打乱)</p>
    
    <button class="btn" onclick="runAnalysis()">开始运行分析</button>
    <div id="loading">正在进行矩阵运算与特征提取...</div>

    <h2>1. 原始人脸数据 (随机展示12张)</h2>
    <p>现在你应该能同时看到笑脸和哭脸了。</p>
    <div id="raw-gallery" class="gallery"></div>

    <h2>2. 提取的特征脸 (Eigenfaces)</h2>
    <div id="eigen-gallery" class="gallery"></div>

    <h2>3. 降维后可视化 (PCA Projection)</h2>
    <div id="scatter-plot" style="width:100%;height:500px;"></div>
</div>

<script>
    const IMG_SIZE = 10;
    const SAMPLE_COUNT = 40; 
    const NUM_COMPONENTS = 2;

    // --- 洗牌算法 (Fisher-Yates Shuffle) ---
    // 用于同时打乱数据和标签，保证对应关系不变
    function shuffleData(data, labels) {
        let currentIndex = data.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [data[currentIndex], data[randomIndex]] = [data[randomIndex], data[currentIndex]];
            [labels[currentIndex], labels[randomIndex]] = [labels[randomIndex], labels[currentIndex]];
        }
        return { data, labels };
    }

    // --- 1. 数据生成部分 ---
    function generateSyntheticFaces() {
        let data = [];
        let labels = [];
        
        for (let i = 0; i < SAMPLE_COUNT; i++) {
            let face = new Array(IMG_SIZE * IMG_SIZE).fill(0);
            // 前一半是笑脸(0)，后一半是哭脸(1)
            const type = i < SAMPLE_COUNT / 2 ? 0 : 1; 
            
            // 眼睛 (左右眼)
            const eyes = [22, 27]; 
            
            // 优化后的嘴型坐标 (10x10网格)
            // 笑脸：嘴角在Row 6，底部在Row 7
            const mouthSmile = [62, 67, 73, 74, 75, 76]; 
            // 哭脸：嘴角在Row 7，顶部在Row 6 (倒U型)
            const mouthFrown = [72, 77, 63, 64, 65, 66]; 
            
            eyes.forEach(idx => face[idx] = 0.8);
            
            if (type === 0) {
                mouthSmile.forEach(idx => face[idx] = 0.7);
            } else {
                mouthFrown.forEach(idx => face[idx] = 0.7);
            }

            // 添加随机噪声
            face = face.map(pixel => {
                let noise = Math.random() * 0.3; 
                return Math.min(pixel + noise, 1.0);
            });

            data.push(face);
            labels.push(type === 0 ? "笑脸" : "哭脸");
        }
        
        // 关键修复：在这里打乱数据！
        return shuffleData(data, labels);
    }

    // --- 2. 绘图辅助函数 ---
    function drawFaceToCanvas(pixelData, containerId, title) {
        const canvas = document.createElement('canvas');
        canvas.width = IMG_SIZE;
        canvas.height = IMG_SIZE;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(IMG_SIZE, IMG_SIZE);

        for (let i = 0; i < pixelData.length; i++) {
            let val = pixelData[i];
            // 简单的可视化映射
            if (val < -0.5) val = -0.5; if(val > 1) val = 1;
            // 负数(特征脸部分)映射为黑色，正数映射为白色
            let colorVal = Math.floor(Math.abs(val) * 255); 
            
            imgData.data[i * 4 + 0] = colorVal; 
            imgData.data[i * 4 + 1] = colorVal; 
            imgData.data[i * 4 + 2] = colorVal; 
            imgData.data[i * 4 + 3] = 255;      
        }
        ctx.putImageData(imgData, 0, 0);

        const div = document.createElement('div');
        div.className = 'face-card';
        div.appendChild(canvas);
        const p = document.createElement('div');
        p.innerText = title;
        div.appendChild(p);
        document.getElementById(containerId).appendChild(div);
    }

    // --- 3. PCA 核心算法 ---
    function performPCA(X) {
        const n_samples = X.length;
        const n_features = X[0].length;
        
        // 1. 中心化
        const mean = new Array(n_features).fill(0);
        for(let j=0; j<n_features; j++) {
            let sum = 0;
            for(let i=0; i<n_samples; i++) sum += X[i][j];
            mean[j] = sum / n_samples;
        }
        const X_centered = X.map(row => row.map((val, j) => val - mean[j]));

        // 2. 协方差矩阵
        const X_mat = math.matrix(X_centered);
        const X_T = math.transpose(X_mat);
        const Cov = math.multiply(X_T, X_mat);
        const Cov_div = math.divide(Cov, n_samples - 1);

        // 3. 特征分解
        const ans = math.eigs(Cov_div);
        
        let eigenPairs = [];
        const values = ans.values.toArray ? ans.values.toArray() : ans.values;
        const vectors = ans.vectors.toArray ? ans.vectors.toArray() : ans.vectors; 

        for(let i=0; i<values.length; i++) {
            let vec = [];
            for(let r=0; r<vectors.length; r++) vec.push(vectors[r][i]);
            eigenPairs.push({ val: values[i], vec: vec });
        }

        eigenPairs.sort((a, b) => b.val - a.val);

        // 4. 投影
        const topVectors = eigenPairs.slice(0, NUM_COMPONENTS).map(p => p.vec);
        const eigenFaces = eigenPairs.slice(0, 5).map(p => p.vec);
        const W = math.transpose(topVectors); 
        const X_projected = math.multiply(X_mat, W).toArray();

        return { projected: X_projected, eigenFaces: eigenFaces };
    }

    // --- 4. 主流程 ---
    function runAnalysis() {
        document.getElementById('loading').style.display = 'block';
        document.getElementById('raw-gallery').innerHTML = '';
        document.getElementById('eigen-gallery').innerHTML = '';
        document.getElementById('scatter-plot').innerHTML = '';

        setTimeout(() => {
            const { data, labels } = generateSyntheticFaces();
            
            // 展示前 12 张 (现在是打乱后的，所以会有笑脸也有哭脸)
            for(let i=0; i<12; i++) {
                drawFaceToCanvas(data[i], 'raw-gallery', labels[i]);
            }

            try {
                const pcaResult = performPCA(data);
                
                pcaResult.eigenFaces.forEach((face, idx) => {
                    drawFaceToCanvas(face, 'eigen-gallery', `Eigen ${idx+1}`);
                });

                plotScatter(pcaResult.projected, labels);
                
            } catch (e) {
                console.error(e);
                alert("运算出错，请检查控制台。");
            }

            document.getElementById('loading').style.display = 'none';
        }, 100);
    }

    function plotScatter(projectedData, labels) {
        let x0 = [], y0 = [], x1 = [], y1 = [];
        
        projectedData.forEach((point, i) => {
            if (labels[i] === "笑脸") {
                x0.push(point[0]);
                y0.push(point[1]);
            } else {
                x1.push(point[0]);
                y1.push(point[1]);
            }
        });

        var trace1 = {
            x: x0, y: y0, mode: 'markers', type: 'scatter',
            name: '笑脸', marker: { size: 12, color: '#2ecc71' }
        };

        var trace2 = {
            x: x1, y: y1, mode: 'markers', type: 'scatter',
            name: '哭脸', marker: { size: 12, color: '#e74c3c' }
        };

        var layout = {
            title: 'PCA 降维结果 (2D)',
            xaxis: { title: '特征维度 1' },
            yaxis: { title: '特征维度 2' },
            hovermode: 'closest'
        };

        Plotly.newPlot('scatter-plot', [trace1, trace2], layout);
    }
</script>
</body>
</html>
